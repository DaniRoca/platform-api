FORMAT: 1A
HOST: https://tenant.acrolinx.cloud

# Acrolinx REST API

The Acrolinx API is the new REST API for accessing all functionality of the Acrolinx server.

Open points are marked with a TODO annotation.

# General headers

## Authorization token

All methods with the exception of "index" and "poll auth token" require a valid auth token in the `X-Acrolinx-Auth` header even if not explicitly mentioned below.
If the token is invalid, a `401` response is returned (see `401` response of "index") even if this response is not explicitly mentioned below.

Example:

```
    X-Acrolinx-Auth: 123579080a8d1fee12490a90dc3
```

## Base URL

To support reverse proxies a client may provide the `X-Acrolinx-Base-Url` header with each request. If the response body to the rquest
contains links into the Acrolinx API, the server will prefix them with the given value. The provided value will be parsed as an URI.
Malformed values will result in a `400` status code.

Example:

```
    X-Acrolinx-Base-Url: https://example.com/path/
```

## Client locale

All methods accept a header `X-Acrolinx-Client-Locale`, with which the client can identify its own locale (e.g. UI language).
The value of the header field must be a single language tag that is compliant to BCP 47. The server will try to return message strings
and other locale-specific parts of the response in the requested language.

Example:

```
    X-Acrolinx-Client-Locale: de-CH
```

The server tries to match the sent locale to the closest locale which it is able to support, for example, "de".
The list of supported locales is returned by the "index" request. The server falls back to the default "en" locale in the following cases:

* no X-Acrolinx-Client-Locale header is sent
* there is no matching supported locale
* for the given response messages etc., there is no appropriate localization available

# Group Index

## Index [GET /api/v1]

Note: This is the only web service method that provides a 200 response if no auth token was sent.
If an invalid auth token was sent, the response is still a 401, though.

+ Request

    + Header

            X-Acrolinx-Auth: ""


+ Response 200 (application/json)

        {
            "server": {
                "version": "5.1.0",
                "build": "12175"
            },
            "locales": [ "en" ],
            "settings": {
                "useLegacyResultDialog": true
            },
            "links": {
                "login": "https://tenant.acrolinx.cloud/api/v1/auth/login"
            }
        }


+ Request

    + Header

            X-Acrolinx-Auth: 123579080a8d1fee12490a90dc3


+ Response 200 (application/json)

        {
            "server": {
                "version": "5.1.0",
                "build": "12175"
            },
            "locales": {
                "en"
            },
            "settings": {
                "useLegacyResultDialog": true
            },
            "links": {
                "login": "https://tenant.acrolinx.cloud/api/v1/auth/login",  // TODO: scoped/namespaced link keys to address Stefan's fears of URL overload?
                "logoff": "https://tenant.acrolinx.cloud/api/v1/auth/logoff",
                "checking": "https://tenant.acrolinx.cloud/api/v1/checking",
                "terminology": "https://tenant.acrolinx.cloud/api/v1/terminology",
                "findability": "https://tenant.acrolinx.cloud/api/v1/findability"
            }
        }


+ Response 401 (application/json)

        {  // if provided auth token became invalid
            "message": "The provided auth token is invalid or has expired.",
            "type": "com.acrolinx.faults.InvalidAuthTokenFault",
            "links": {
                "login": "https://tenant.acrolinx.cloud/api/v1/auth/login"
            }
        }

# Group Authentication API

Authentication is handled in a semi-interactive fashion as described in DEV-10327 ("unified authentication").
For headless/non-interactive integrations, an alternative is to create an API key in the dashboard.

## Request a new login [POST /api/v1/auth/login{?locale}]

The login resource allows Acrolinx API clients to request user authentication and to check
the validity and privileges of exisiting *Auth Tokens*.

If the Acrolinx server is configured for Single Sign-on this enpoint will accept the configured sso credentials
to authenticate the request.

+ Request (application/json)

    + Header

            X-Acrolinx-Auth: 123579080a8d1fee12490a90dc3 (valid) OR (invalid/expired auth token) OR (no auth token)
            X-Acrolinx-Client-Locale: ja

    + Body

            {
                "clientName": "My Test Client"
            }

+ Response 200 (application/json)
    If the `X-Acrolinx-Auth` header contained a valid token, the login resource
    produces the login result immediately. This will also happen if Single Sign-on
    is configured and valid credentials are supplied.

    The token returned in the body is the same as the one provided in the header.

    + Attributes (LoginResponse)

+ Response 201 (application/json)
    If the `X-Acrolinx-Auth` header was absent a
    new authorization process is started. The response body to the login request
    will contain two links that allow the user to complete the login process and
    the client to acquire the session data:

    - `interactive` a link to a website that allows the user to authenticate and
          permit the client to log in. If a language was provided in the
          `X-Acrolinx-Client-Locale` header, the link will point to a localized
          version of that website if available and technically possible.

    - `poll` a link to a resource that will return an *Auth Token* and information
          about the user after login. (see [GET `api/v1/auth/poll`](#authentication-api-poll-for-auth-token-get))

    + Body

            {
                "links": {
                    "interactive": "https://tenant.acrolinx.cloud/dashboard.html?login=19901-2-8412998412",
                    "poll": "https://tenant.acrolinx.cloud/api/v1/auth/poll/185-0ijfgklejt2390tui"
                }
            }

+ Response 401 (application/json)
    If invalid SSO credentials are supplied (a user name is present but the SSO password is wrong or
    missing or the user could not be created) the request is rejected.

    + Header

            WWW-Authenticate: ACROLINX_TOKEN, ACROLINX_SIGN_IN (, ACROLINX_SSO)

    + Attributes
        + error (ErrorResponse)

+ Response 503
    The server is unable to start a login process at this time.

    + Header

            Retry-After: 30

    + Attributes
        + error (ErrorResponse)

## Poll for Auth token [GET /api/v1/auth/poll/{id}]

This resource lets a client wait for a user to login and authorize it to use the
priviliged parts of the Acrolinx API. Once the user has completed the login process
it will return a new *Auth Token* that can be send with each API call to prove
the privileges requested during the initiating [POST to `/api/v1/auth/login`](#authentication-api-request-a-new-login-post).

This action supports long polling. A request may be kept open for a "long" duration
and will only return on a timeout or when the login process has reached a final state.
Once polling returned a final result (`GONE`/`UNAUTHORIZED`/`OK`) the polling
endpoint will dissapear with `GONE` or `NOT FOUND`.

+ Parameters
    + id: `99576707-ed8c-44b6-82b8-c3ced8f349d1` (string, required) - poll-id for the authorization request

+ Response 200 (application/json)
   A user has completed the login process and the server has created a new *Auth Token*.

   Note that this resource will dissapear after this response.

   + Attributes (LoginResponse)

+ Response 202 (application/json)
   Another poll request was started an has replaced this one before the user completed the authorization or
   the server decided to drop the poll request. Request the same URI again to continue polling.

    + Header

            Retry-After: 2

    + Attributes
        + error (ErrorResponse)

+ Response 404
    The server has no knowledge of the polling token. This may be caused by a timeout or by antoher poll request that consumed the credentials already.

    + Attributes
        + error (ErrorResponse)

+ Response 410 (application/json)
    Returned when the requested login process has timed out.

    + Attributes
        + error (ErrorResponse)

## Logoff [POST /api/v1/auth/logoff]

+ Request

    + Header

            X-Acrolinx-Auth: 123579080a8d1fee12490a90dc3

+ Response 204


# Group User API

Here, a user is an entity that has a login name, first/last name, privileges, custom properties (set by client), and user metadata.
TODO: This may throw together too many concepts at once?

In case user metadata is _required_:
* Interactive integrations: This will already be handled via unified authentication. Immediately before granting
access to an integration, the user needs to fill out his/her user metadata. It is thus impossible to obtain an
auth token for a user with incomplete required user metadata.
* Headless (API key-based) integations: This will be handled by dashboard access. After logging in to the dashboard,
the user needs to fill out his/her user metadata before getting to the actual dashboard. API keys can only be obtained
in the dashboard for the logged-in user. It is thus impossible to obtain an API key for a user with incomplete required user metadata.
* TODO: If you enable 'require UMD' in the dashboard, should this invalidate all API keys and auth tokens at that point?

## User resource [/api/v1/user/{id}]

+ Parameters
    + id: `fred` (required, string) ... the user ID

### Get User [GET]

+ Response 200 (application/json)

        {
            "id": "fred",
            "name": "fred",  // Acrolinx login name (user ID) - TODO: is this already a suitable ID?
            "firstName": "Fred",   //
            "lastName": "Freelancer", //
            "tenantId": "smarttech",
            "privileges": [ "CheckingAndClients.checkingApplications", "CheckingAndClients.submitDictionaryEntry", "UserAndRoles.read" ],
            "properties" : {
                "customkey": "customvalue",
            }
            "metadata":
            {
                "displayName": "Department",
                "key": "department",
                "value": "IT",
                "possibleValues": [],
                "default": null
            }
        }

+ Response 403 (application/json)

        // if auth token does not permit to show the user's data
        {
            "message": "You are not allowed to perform this operation.",
            "type": "com.acrolinx.faults.InsufficientPrivileges",
        }

### Update User [PUT]

TODO: Which user information can be updated with this call? Are partial updates allowed?

+ Request (application/json)

        {
            "firstName": "Freddy",
            "lastName": "McFredFace",
            "privileges": [ "CheckingAndClients.checkingApplications", "CheckingAndClients.submitDictionaryEntry" ],
            "properties" : {
                "customkeynew": "customvaluenew",
            }
            "metadata":
            {
                "key": "department",
                "value": "Manager",
            }
        }


+ Response 200 (application/json)

        {
            "id": "fred",
            "name": "fred",
            "firstName": "Freddy",
            "lastName": "McFredFace",
            "tenantId": "smarttech",
            "privileges": [ "CheckingAndClients.checkingApplications", "CheckingAndClients.submitDictionaryEntry" ],
            "properties" : {
                "customkeynew": "customvaluenew",
            }
            "metadata":
            {
                "displayName": "Department",
                "key": "department",
                "value": "Manager",
                "possibleValues": [],
                "default": null
            }
        }

+ Response 403 (application/json)

        // if client tried to change certain fields and the auth token does not permit it
        {
            "message": "You are not allowed to perform this operation.",
            "type": "com.acrolinx.faults.InsufficientPrivileges",
        }

# Group Document API

Here, a document is an entity that associates names/characteristics which identify a document with an ID. It also contains the document metadata.

TODO: What about the document display title? Set by client here? Extracted by server here? Extracted by server later during check, i.e. not part of document entity?

TODO: How does this relate to the content repositories in the reporting DB? Is it orthogonal?

## Create or retrieve document ID [POST /api/v1/document/_search{?forceNew}]

In this method, fields in payload are used to (a) associate ID with document info, (b) search for existing ID that matches given fields.

* Parameters
    * forceNew: `true` (optional, boolean) ... create a new document ID even if there is a matching existing document

        Default: false

+ Request (application/json)

        {
            "reference": "abc.docx",            // optional; if absent, forceNew is implicitly true (=no searching)
            "mimeType": "application/word",     // optional; absent means "unknown" and matches only "unknown"
            "author": "Ralf",                   // optional; absent means "unknown" and matches only "unknown"
            "contentType": "E-Mail"             // optional; absent means "unknown" and matches only "unknown"
        }

+ Response 200 (application/json)

        {
            "id": "283ab1e075f21a",
            "reference": "abc.docx",
            "mimeType": "application/word",
            "author": "Ralf",
            "contentType": "E-Mail"
            "metadata": [
                {
                    "displayName": "Project ID",
                    "key": "projectId",
                    "value": null,
                    "required": true
                }
            ]
        }

## Put/update document [PUT /api/v1/document/{id}]

+ Request (application/json)

        {
            "reference": "abc.docx",
            "mimeType": "application/word",
            "author": "Ralf",
            "contentType": "E-Mail",
            "metadata": [
                {
                    "key": "projectId",
                    "value": "Marketing Campaign"
                }
            ]
        }


+ Response 200 (application/json)

        {
            "id": "283ab1e075f21a",
            "reference": "abc.docx",
            "mimeType": "application/word",
            "author": "Ralf",
            "contentType": "E-Mail",
            "metadata": [
                {
                    "displayName": "Project ID",
                    "key": "projectId",
                    "value": "Marketing Campaign",
                    "required": true
                }
            ]
        }



# Group Content Encodings - DEV-11069

In the proposal below, the document is embedded as a JSON string in the "content" field. The "contentEncoding" field determines how the field is used. With "contentEncoding=none", the document text is embedded as-is. It needs to be encoded in the same way as the entire HTTP request, and it must not contain BOMs. Use any of the other contentEncodings (e.g. base64) for binary documents or plain text documents that have a different encoding than the HTTP request encoding and/or that have a BOM. In this case, it is up to the server to preserve the byte stream (for binary formats), and to guess the charset correctly (for text formats).

TODO: For text documents (plain text/HTML/XML), we may need a way for the client to specify the charset explicitly instead letting the server guess it, because the returned offsets refer to the (decoded) content string.

TODO: XML documents can include their own charset in the header - not sure whether we want to respect that, and what happens if this contradicts the BOM and/or the charset explicitly sent by the client.

TODO: An alternative approach would be to offer multipart/mixed requests, such that the client can just send the request as byte stream in a second part (first part contains the JSON request entity without the document contents). Advantage: could send more files at once in the future; can rely on HTTP standards for specifying the encoding etc. Disadvantages:  multipart/mixed may be more difficult for some clients, and HTTP does not support sending compressed requests.

TODO: For the record: The current 5.2 server expects the document contents to be embedded as JSON string, with the same encoding as the request encoding, and without any BOMs. Exception: for inputFormat=PDF, the (binary) document contents must be sent base64-encoded.

# Group Checking API

The API for checking documents.

## List all checking methods [GET /api/v1/checking]

TODO: Do we need this entrance point? We could move 'capabilities' and 'submit' to the index.

+ Response 200 (application/json)

        {
            "inputFormats": [], // TODO: why is this here again?
            "links": {
                "submit": "https://tenant.acrolinx.cloud/api/v1/checking/submit",
                "capabilities": "https://tenant.acrolinx.cloud/api/v1/checking/capabilities",
            }
        }

## List checking capabilities [GET /api/v1/checking/capabilities]

TODO: what about sublanguages? Part of the audience, or selectable by client?

+ Response 200 (application/json)

        {
            "audiences": [
                {
                    "id": "aud-1",
                    "displayName": "Tom the Technical Type",
                    "language": "en_GB",
                    "goals": ["spelling", "voice.readability", "term.unsuitable", "term.admitted"],
                    "termSets": ["c58f3889-9466-4fb4-82c7-973a0b4644d9", "e57bf41b-c706-495c-8664-1020fac9cffb"]
                }
            ],
            "languages": [
                {
                    "id": "en_GB",
                    "displayName": "English (Great Britain)"
                }
            ],
            "goals": [
                {
                    "id": "spelling",
                    "displayName": "Spelling",
                    "col": "#f21"
                },
                {
                    "id": "voice.readability",
                    "displayName": "Clarity",
                    "col": "#f22"
                },
                {
                    "id": "term.unsuitable",
                    "displayName": "Unsuitable Term",
                    "col": "#f23"
                },
                {
                    "id": "term.admitted",
                    "displayName": "Use with caution",
                    "col": "#f24"
                }
            ],
            "termSets": [
                {
                    "id": "c58f3889-9466-4fb4-82c7-973a0b4644d9",   // actually the T+ term filter UUID
                    "displayName": "Switches"
                },
                {
                    "id": "e57bf41b-c706-495c-8664-1020fac9cffb",
                    "displayName": "Acrolinx"
                }
            ]
            "contentFormats": [
                {
                    "id": "auto",
                    "displayName": "Automatic Detection",   // TODO: what do we do with this again?
                    "extensions": ["*"]                     // TODO: what do we do with this again?
                },
                {
                    "id": "text",
                    "displayName": "Plain Text",
                    "extensions": ["txt"]
                },
                {
                    "id": "markdown",
                    "displayName": "Markdown",
                    "extensions": ["md"]
                },
                {
                    "id": "xml",
                    "displayName": "XML",
                    "extension": ["xml", "dita", "docbook"]
                },
                {
                    "id": "word_xml",
                    "displayName": "XML (MS Word 2003)",
                    "extension": ["xml"]
                }
            ],
            "contentEncodings": [ "none", "zip,base64", "base64" ],
            "checkTypes": [ "batch", "partial", "interactive" ],
            "reportTypes": ["scorecard.xml", "scorecard.html", "debug", "termharvesting"]
        }

##  Submit a check [POST /api/v1/checking/submit]

This call includes an implicit "create/search for document" (in case no document ID was given) and "update document" (in case document ID was given).

+ Request (application/json)

        {
            "content": "text to check",                  // required
            "contentEncoding": "zip,base64",             // optional, default: none = HTTP request encoding
            "checkOptions": {
                "audienceId": "aud-1",                       // optional, default: first audience
                "termSetIds": ["c58f3889-9466-4fb4-82c7-973a0b4644d9"],    // optional, default: all available for audience
                "reportTypes": ["debug", "termharvesting"],  // optional, default: scorecard.html
                "contentFormat": "word_xml",                 // optional, default: auto
                "checkType": "partial",                      // optional, default: interactive
                "partialCheckRanges": [{ "begin": "10", "end": "20" }, { "begin": "40", "end": "70" }]   // only used when checkType=partial
            },
            "batchId": "159203590",                      // only when checkType=batch; optional; if absent: server creates new batchId (sent in response)
            "document": {                                // optional, default: empty "document" object
                "id": "283ab1e075f21a",                  // optional; if present: update with following non-null infos (if any); if absent: search for or create ID with following infos
                "reference": "abc.docx",                 // optional, default: do not search for ID, always create
                "author": "Ralf",
                "mimeType": "application/word",
                "contentType": "E-Mail",
                "metadata": null
            },
            // TODO (asked by ska): needed if already sent during authentication? can we store this with auth token?
            "clientInfo": {                              // optional, used for CSD selection and reporting
                "signature": "QWNyb2xpbnhGb3JJbkZvckFkb2JlSW5EZXNpZ24",
                "displayName": "Acrolinx Plug-in for Adobe InDesign",
                "version": "1.2",
                "build": "4201"
            }
        }

+ Response 200 (application/json)

        {
            "id": "153",
            "batchId": "159203590",
            "checkOptions": {
                "audienceId": "aud_1",
                "termSetIds": ["c58f3889-9466-4fb4-82c7-973a0b4644d9"],
                "reportTypes": ["debug", "termharvesting"],
                "contentFormat": "word_xml",
                "checkType": "partial",
                "partialCheckRanges": [{ "begin": "10", "end": "20" }, { "begin": "40", "end": "70" }]
            },
            "document": {
                "id": "283ab1e075f21a",
                "reference": "abc.docx",
                "author": "Ralf",
                "mimeType": "application/word",
                "contentType": "E-Mail",
                "metadata": [
                    {
                        "displayName": "Project ID",
                        "key": "projectId",
                        "value": "Marketing Campaign",
                        "required": true
                    }
                ]
            },
            "links": {
                "status": "https://tenant.acrolinx.cloud/api/v1/checking/153/status",
                "cancel": "https://tenant.acrolinx.cloud/api/v1/checking/153"
            }
        }

+ Response 400 (application/json)

        // TODO: non-interactive/batch clients should be able to check without required DMD
        {
            "message": "Document Metadata required",
            "type": "com.acrolinx.faults.DocumentMetadataRequired",
            "document": {
                "id": "283ab1e075f21a",
                "reference": "abc.docx",
                "mimeType": "application/word",
                "author": "Ralf",
                "contentType": "E-Mail",
                "metadata": [
                    {
                        "displayName": "Project ID",
                        "key": "projectId",
                        "value": null,
                        "required": true
                    }
                ]
            }
            "links": {
                "submitMetadata": "https://tenant.acrolinx.cloud/api/v1/document/283ab1e075f21a/metadata"
            },
            "actions": [
                {
                    "id": "submitMetadataForm",
                    "url": "https://host:8031/documentMetadata.html?documentId=283ab1e075f21a",
                    "displayName": "Add required document metadata",
                    "icon": "..."
                }
            ]
        }


## Cancel check [DELETE /api/v1/checking/{id}/cancel]

+ Parameters
    + id: `153` (required, number) ... the check id

+ Response 204

## Get check status [GET /api/v1/checking/{id}/status]

+ Parameters
    + id: `153` (required, number) ... the check id

+ Response 200 (application/json)

        {
            "id": "153",
            "documentId": "283ab1e075f21a",
            "state": "done",
            "percent": 100,
            "message": "(10/10) Done."
            "links": {
                "result": "https://tenant.acrolinx.cloud/api/v1/checking/153/result"
            }
        }

## Get check result [GET /api/v1/checking/{id}/result]

+ Parameters
    + id: `153` (required, number) ... the check id

+ Response 200 (application/json)

        {
            "id": "153",
            "checkOptions": {
                "audienceId": "aud_1",
                "termSetIds": ["c58f3889-9466-4fb4-82c7-973a0b4644d9"],
                "reportTypes": ["debug", "termharvesting"],
                "contentFormat": "word_xml",
                "checkType": "partial",
                "partialCheckRanges": [{ "begin": "10", "end": "20" }, { "begin": "40", "end": "70" }]
            },
            "document": {
                "id": "283ab1e075f21a",
                "reference": "abc.docx",
                "mimeType": "application/word",
                "author": "Ralf",
                "contentType": "E-Mail",
                "metadata": [
                    {
                        "displayName": "Project ID",
                        "key": "projectId",
                        "value": "Marketing Campaign",
                        "required": true
                    }
                ]
            },
            "quality": {
                "score": 57,
                "status": "red"   // TODO: which values are allowed?
            },
            "counts": {
                "sentences": 10,
                "words": 121,
                "issues": 15
            },
            "goals": [
                {
                    "id": "spelling",
                    "displayName": "Spelling",
                    "col": "#f21",
                    "issueCount": 13,
                },
                {
                    "id": "voice.readability",
                    "displayName": "Clarity",
                    "col": "#f22"
                    "issueCount": 2,
                },
                {
                    "id": "term.unsuitable",
                    "displayName": "Unsuitable Term",
                    "col": "#f23",
                    "issueCount": 0
                }
            ],
            "issues": [
                {
                    "goalId": "spelling",
                    "internalName": "title_case_chicago",
                    "displayName": "Use Chicago style for the title case?",
                    "guidance": "<div class=\"shortHelp\" lang=\"en\" xml:lang=\"en\">\n<p>According to the <q>Chicago Manual of Style</q>, here's how you write titles:</p>\n<ul>\n<li>Capitalize the first word and the last word.</li>\n<li>Capitalize all \"main\" words.</li>\n<li>Don't capitalize articles and conjunctions (example: <q>a</q>, <q>and</q>).</li>\n<li>Don't capitalize prepositions independent of their length (example: <q>about</q>, <q>around</q>).</li>\n</ul>\n</div>",
                    "extractedSurface": "zentense"
                    "positionalInformation": {
                        "hashes": {           // TODO: positional info? groupId grouped flags based on type (e.g. all flags of a rule), but issue hash just groups internalName+extractedSurface
                            "issue": "BhKh3iaGBjB7Cw6M/GwrLQ==",
                            "environment": "vJ9eCVViEpIdM76h+5K/nA==",
                            "index": "hjlRLT0K+LlvlslKdNUlhw==1"
                        },
                        "matches": [{
                            "extractedPart": "zen",
                            "extractedBegin": 30,
                            "extractedEnd": 33,
                            "originalPart": "zen",
                            "originalBegin": 19247,
                            "originalEnd": 19255
                        }, {
                            "extractedPart": "te",
                            "extractedBegin": 33,
                            "extractedEnd": 35,
                            "originalPart": "&te;",
                            "originalBegin": 19250,
                            "originalEnd": 19254
                        },{
                            "extractedPart": "nse",
                            "extractedBegin": 35,
                            "extractedEnd": 38,
                            "originalPart": "nse",
                            "originalBegin": 19254,
                            "originalEnd": 19257
                        }]
                    },
                    "readonly": true,
                    "issueLocations": [
                        {
                            "locationId": "pageLocation",
                            "displayName": "Page 4",
                            "values": { "page": "4" }
                        }
                    ],
                    "suggestions": [
                        {
                            "surface": "sentence",
                            "groupId": "sentence",
                            "replacements": {
                                0: "sen",
                                2: "nce"
                            }
                        }
                    ],
                    "actions": [
                        {
                            "id": "help",
                            "url": "https://tenant.acrolinx.cloud/htmldata/en/rules/help/title_case_chicago.html",
                            "displayName": "Help",
                            "icon": "help-icon"
                        },
                        {
                            "id": "termContributionForm",
                            "url": "https://tenant.acrolinx.cloud/termcontribution.html?surface=@@base64:cXdlcnR5dWlvcA==&locale=en&language=en&userid=admin&context=@@base64:VGhpcyBzZW50ZW5jZSBoYXMgYSBxd2VydHl1aW9wLg==#",
                            "displayName": "Add as Term",
                            "icon": "icon-term-contribute",
                            "replacedBy": "termContribution"
                        }
                    ],
                    "links":
                        {
                            "termContribution": "https://tenant.acrolinx.cloud/terminology/v7/rest/contribute",
                            "addToDictionary": "https://tenant.acrolinx.cloud/api/v1/dictionary/submit"
                        }
                },
                {
                    "goalId": "term.unsuitable",
                    "internalName": "term_flag",
                    "displayName": "<b>Illegal sublanguage variant</b> of preferred term",
                    "guidance": "<div class=\"guidance term\">\n\t<b>Domains</b>\n\t\t\t<br/><i>Switches</i>\n\t\t\t\t\t<br/>\n\t\t<b>Note</b>\n\t\t<br/>\n\t\tUse &#39;please&#39; in presale materials only. Do NOT use &#39;please&#39; in postsale material.\n\t</div>\n",
                    "extractedSurface": "Please"
                    "positionalInformation": {
                        "hashes": {
                            "issue": "3qyt/AVxwNTOUQSuMA7brw==",
                            "environment": "TiwIFBwA6X920mDAezJTyQ==",
                            "index": "Lm9PqBGGm+tj21rt3pkpjA==1"
                        },
                        "matches": [{
                            "extractedPart": "Please",
                            "extractedBegin": 766,
                            "extractedEnd": 772
                            "originalPart": "Please",
                            "originalBegin": 28223,
                            "originalEnd": 28229,
                        }],
                    },
                    "readonly": false,
                    "issueLocations": [],
                    "suggestions": [
                        {
                            "surface": "blablub",
                            "icon": "https://tenant.acrolinx.cloud/tng/icons/preferred.svg" // TODO: icon class+url?
                            "groupId": "2653",
                            "replacements": {
                                0: "blablub"
                            }
                        }
                    ],
                    "actions": [
                        {
                            "id": "help",
                            "url": "https://tenant.acrolinx.cloud/termhelp?termUniversalId=9c2e9ffb-a314-4b61-94b2-d62db3c18945&locale=en",
                            "displayName": "Help",
                            "icon": "help-icon"
                        }
                    ],
                    "debug": {
                        "term": {
                            "surface": "please",
                            "status": "DEPRECATED",
                            "termSets": ["RA-Terms"],
                            "domains": ["RA-Terms"]
                            "variant": "legalVariantIllegal",
                        }
                    }
                },
                {
                    "goalId": "voice.readability",
                    "internalName": "en-clarity-medium",
                    "displayName": "Too complex? Your readers need a medium level of clarity. ",
                    "guidance": "",
                    "extractedSurface": "Reports ... length",
                    "positionalInformation": {
                        "hashes": {
                            "issue": "E3OxJ3bFcfWLyAisUxufAA==",
                            "environment": "XVYQZVyCoFOr1TDeyXuMgg==",
                            "index": "accsS0dbn/3rafcbT9NJGw==1"
                        },
                        "matches": [{
                            "extractedPart": "Reports",
                            "extractedBegin": 1360,
                            "extractedEnd": 1367
                            "originalPart": "Reports",
                            "originalBegin": 33173,
                            "originalEnd": 33180,
                        }, {
                            "extractedPart": "length",
                            "extractedBegin": 1749,
                            "extractedEnd": 1755
                            "originalPart": "length",
                            "originalBegin": 33562,
                            "originalEnd": 33568,
                        }]
                    },
                    "suggestions": [],
                    "issueLocations": [],
                    "readonly": false,
                    "debug": {
                        "penalty": 1234.0967741949999
                    },
                    "subIssues": [{
                        "goalId": "voice.readability",
                        "internalName": "phenomenon_embedded_or_complex_sentence",
                        "displayName": "Try to split up this sentence.",
                        "guidance": "<p>This sentence doesn't seem to flow smoothly. We found a few embedded phrases in there that could be messing with your flow somehow.</p>",
                        "extractedSurface": "Reports ... length",
                        "positionalInformation": {
                            "hashes": {
                                "issue": "7s1nqUN96X+P6VY4FlfSQQ==",
                                "environment": "XVYQZVyCoFOr1TDeyXuMgg==",
                                "index": "++0c1Z/OQu1Mwzt0KpkYYA==1"
                            },
                            "matches": [{
                                "extractedPart": "Reports",
                                "extractedBegin": 1360,
                                "extractedEnd": 1367
                                "originalPart": "Reports",
                                "originalBegin": 33173,
                                "originalEnd": 33180,
                            }, {
                                "extractedPart": "length",
                                "extractedBegin": 1749,
                                "extractedEnd": 1755
                                "originalPart": "length",
                                "originalBegin": 33562,
                                "originalEnd": 33568,
                            }]
                        },
                        "suggestions": [],
                        "issueLocations": [],
                        "readonly": false,
                        "debug": {
                            "penalty": 320.0
                        }
                    }, {
                        "goalId": "voice.readability",
                        "internalName": "phenomenon_passive",
                        "displayName": "The active voice is usually clearer.",
                        "guidance": "<p>This one could do with a bit of pep. It's probably because it feels kind of passive. We love it when you're assertive.</p>",
                        "extractedSurface": "was first seen",
                        "positionalInformation": {
                            "hashes": {
                                "flag": "dg+ih1XodWeL7lJ/wo17QQ==",
                                "environment": "XVYQZVyCoFOr1TDeyXuMgg==",
                                "index": "fOJLASZHiwnwcJWcfbkXnw==1"
                            },
                            "matches": [{
                                "part": "was",
                                "begin": 33219,
                                "end": 33222,
                                "extractedBegin": 1406,
                                "extractedEnd": 1409
                            }, {
                                "part": "first",
                                "begin": 33223,
                                "end": 33228,
                                "extractedBegin": 1410,
                                "extractedEnd": 1415
                            }, {
                                "part": "seen",
                                "begin": 33229,
                                "end": 33233,
                                "extractedBegin": 1416,
                                "extractedEnd": 1420
                            }]
                        },
                        "suggestions": [],
                        "issueLocations": [],
                        "readonly": false,
                        "debug": {
                            "penalty": 40.0
                        }
                    }]
                }
            ],
            "keywords": [
                "links": {
                    "getTargetKeywords": "https://tenant.acrolinx.cloud/services/v1/rest/findability/targetKeywords?contextId=C%3A%5CUsers%5Cgrabowski%5CDesktop%5Ccloud-linguistic-smoketest.docx",
                    "putTargetKeywords": "https://tenant.acrolinx.cloud/services/v1/rest/findability/targetKeywords?contextId=C%3A%5CUsers%5Cgrabowski%5CDesktop%5Ccloud-linguistic-smoketest.docx"
                },
                "discovered": [{
                    "keyword": "Clarity card",
                    "sortKey": "10",
                    "density": 0.2546269436736127,
                    "count": 4,
                    "prominence": 0.0,
                    "occurrences": [{
                        "matches": [
                          // ...
                        ]
                    }],
                    "warnings": []
                }],
                "target": []
            ],
            "extraInfos": [
                {
                    "id": "rioseo",
                    "title": "IBM KIS",
                    "iconClass": "search-icon",
                    "iconUrl": "...",
                    "url": "https://kis.example.com/info?projectId=52351235"
                }
            ],
            "reports": [
                {
                    "reportType": "scorecard.html",
                    "link": "https://tenant.acrolinx.cloud/output/en/abcdef_1_report.html"
                },
                {
                    "reportType": "scorecard.xml",
                    "link": "https://tenant.acrolinx.cloud/output/en/abcdef_1_report.xml"
                }
            ],
            "actions": [
                {
                    "id": "termContributionForm",
                    "url": "https://tenant.acrolinx.cloud/termcontribution.html",
                    "displayName": "Add as Term",
                    "icon": "icon-term-contribute",
                    "replacedBy": "termContribution"
                }
            ],
            "links":
                {
                    "termContribution": "https://tenant.acrolinx.cloud/terminology/rest/v7/contribute",
                    "deleteScorecard": "https://tenant.acrolinx.cloud/api/v1/checking/153/result"
                }
        }

## Get link to aggregated report [GET /api/v1/checking/aggregation/{batchId}]

Returns the links to a human readable Analytics Dashboard, which aggregates information of all checks belonging to the given batch id. Requires the Reporting.read privilege. The link with API key contains a new privilege token with the right Reporting.read.

+ Parameters
    + batchId: `XYZ-10-22-33` (required, string) ... the batch check id

+ Response 200 (application/json)

        {
            "reports": [
                {
                    "reportType": "withoutApiKey",
                    "link": "https://tenant.acrolinx.cloud/analytics/dashboard/app/entry/run.jsp?jrd_resext=%7Bactive%3A0%2Creslst%3A%5B%7Bname%3A%22%2FAcrolinxReports%2Fstandard%2FContent+Analysis.dsh%22%2C%22param_page%22%3Afalse%2Cver%3A-1%2C%22dsh_params%22%3A%5B%7B%22jrd_params%22%3A%7B%22BatchId%22%3A%22_nice_batch_id_88-xyz%22%2C%22CsBaseUrl%22%3A%22http%3A%2F%2Flocalhost%3A8031%22%2C%22CsOutputPath%22%3A%22%2Foutput%22%7D%7D%5D%7D%5D%7D&jrd_userinfo=%7B%22prefer%22%3A%7B%22rpt_lang%22%3A%22en%22%2C%22enableNLS%22%3Atrue%7D%7D&jrs.language=en"
                },
                {
                    "reportType": "withApiKey",
                    "link": "https://tenant.acrolinx.cloud/analytics/dashboard/app/entry/run.jsp?jrd_resext=%7Bactive%3A0%2Creslst%3A%5B%7Bname%3A%22%2FAcrolinxReports%2Fstandard%2FContent+Analysis.dsh%22%2C%22param_page%22%3Afalse%2Cver%3A-1%2C%22dsh_params%22%3A%5B%7B%22jrd_params%22%3A%7B%22BatchId%22%3A%22_nice_batch_id_88-xyz%22%2C%22CsBaseUrl%22%3A%22http%3A%2F%2Flocalhost%3A8031%22%2C%22CsOutputPath%22%3A%22%2Foutput%22%7D%7D%5D%7D%5D%7D&jrd_userinfo=%7B%22prefer%22%3A%7B%22rpt_lang%22%3A%22en%22%2C%22enableNLS%22%3Atrue%7D%7D&jrs.language=en&apikey=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImFjcm9saW54OjA4MTEwYThjNzI3MjQzYTMiLCJuYmYiOjE1MDM5MjcyMzksImlzcyI6ImFjcm9saW54OjA4MTEwYThjNzI3MjQzYTM6NWQyNTQ2NWI5ZTA3NDNiZiIsImV4cCI6MTUwNjYwNTYzOSwidG9rZW5UeXBlIjoidXNlciIsImlhdCI6MTUwNDAxMzYzOSwianRpIjoiMmFmOTQzOWIzZDgyNzMwODAyMzMyMzEyMGRiZmRlMmYifQ.Lj0chsnnRTX7IevJNyWMMlCviA6ecYAQ0kacy5EGQz0"
                }
            ]
        }

# Group Dictionary API

This API handles the spelling dictionary, i.e. words that are ignored by the spell checker.
Here, a dictionary entry is a surface string and a language, optionally further restricted
by either an audience ID, a document ID or a user ID.

## Get dictionary capabilities [GET /api/v1/dictionary/capabilities]

This method enables the client to discover the supported dictionary scopes.

+ Response 200 (application/json)

        {
            "scopes": [ "audience", "document", "user", "language" ]
        }

## Add to dictionary [POST /api/v1/dictionary/submit]

Create a dictionary entry for the specified scope. Depending on the scope, more information is required -
the client needs to know which information it is. The response is the created dictionary entry.

+ Request (application/json)

        {
            "surface": "wiruwaruwolz",                  // required
            "scope": "document"                         // required, one of the scopes above
            "languageId": "en_GB",                      // required if scope!=audience
            "audienceId": "aud-1",                      // required if scope=audience
            "documentId": "283ab1e075f21a"              // required if scope=document
            "userId": "fred"                            // optional, default: user from auth token
        }

+ Response 200

        {
            "surface": "wiruwaruwolz",
            "scope": "document"
            "languageId": "en_GB",
            "audienceId": null,
            "documentId": "283ab1e075f21a",
            "userId": null
        }

# Search for dictionary entries [POST /api/v1/dictionary/search]

This is new functionality intended to make the contents of the spelling dictionary transparent for the first time.
The dictionary entry in the request payload is used as the search criteria, where "null" fields mean "any".
The response is a list of all entries across all dictionaries where the entry fields match the non-null criteria exactly.

+ Request (application/json)

        {
            "surface": "wiruwaruwolz",
            "scope": null,
            "languageId": "en_GB",
            "audienceId": null,
            "documentId": null
            "userId": null
        }

+ Response 200

        [
            {
                "surface": "wiruwaruwolz",
                "scope": "document"
                "languageId": "en_GB",
                "audienceId": null,
                "documentId": "283ab1e075f21a",
                "userId": null
            },
            {
                "surface": "wiruwaruwolz",
                "scope": "user"
                "languageId": "en_GB",
                "audienceId": null,
                "documentId": null,
                "userId": "fred"
            }
        ]


# Data Structures

## LoginResponse (object)
+ `authToken`: `123579080a8d1fee12490a90dc3` (string, required)
+ `authorizedUsing`: `ACROLINX_SIGN_IN` (enum[string], required)
    + Members
        + `ACROLINX_SIGN_IN` - Authorized by the user signing in via the Acrolinx Sing-in website.
        + `ACROLINX_TOKEN` - Authorized by a token provided with the request.
        + `ACROLINX_SSO` - Authorized by single sign-on credentials provided with the request.
+ `privileges`: CheckingAndClients.checkingApplications, CheckingAndClients.submitDictionaryEntry (array[string], required)
+ `userId`: `fred` (string, optional)
+ `links` (optional)
    + `user`: `https://tenant.acrolinx.cloud/api/v1/user/fred` (string, optional)

## View (object)
+ id: `850ec0e3-9dd2-48f0-bb9c-8ade80316584` (string)
+ displayName: `Hello World` (string, required)
+ useForChecking: false (boolean) - marks that this view is used to generate term sets
+ query: `name=match(batman)` (string, required) - a query string that may be appended to the terms resource to fetch terms in this view
+ links: (optional)
    + *terms/en*: `[link to the terms collection]` (string, optional) - for each check language with terms matching the query there will be a link to the terms resource that returns these terms
+ NOT_UP_TO_DATE: yes (string, optional)

## Term (object)
+ `id`: `B4B198A5-459C-4CF9-A574-22A22F611B8A` (string)
+ `name`: `Gàidhlig` (string)
+ `languageCode`: `gd` (string)
+ `status`: `39718e03-55b5-4874-a9c2-05edd83d58cb` (string)
+ `concept`: `589E1B07-34BE-4308-A6E9-40731DCFD30A` (string)
+ NOT_UP_TO_DATE: yes (string, optional)

## ErrorResponse (object)
+ `message`: `Error message` (string)
+ `errors`: (required)
    + `exception_type`: `com.acrolinx.services.faults.Unauthorized` (string, required)
    + `exception_message`: `Invalid credentials` (string, required)

## PaginationMetadata (object)
+ `page`: `1` (number)
+ `pages`: `1` (number)
+ `limit`: `10` (number)
+ `records`: `2` (number) - total number of records in query, independent of pagination

## `Language` (object)
- `id`: `bf2b3b68-c3c2-4924-aaa3-e755f5cfd3d3` (string)
- checkedAs: en de zh (array[string], optional) - language codes that this language is checked as (not final)
- `parentLanguage`: `b0a5f8d9-9fb3-4c4d-90ea-15acad32ca11` (string)
- `name`: `hup` (string)
- `displayName`: `Hupa` (string) - use this string to represent this language in your UI
- `order`: `33` (number) - represents the visual order between siblings, not necessary continous or complete

# Group Terminology API

This API allows access to the terminology database.

## Get terminology index - not implemented [GET /api/v1/terminology]

Basic hints about what is available where in the api. Links may appear/disappear based on the authorizations in the token provided.

TODO:
+ put more stuff into the object, such as
    + languages
    + statuses (???)
    + custom fields
    + (maybe: views)
+ put more links into the object:
    + links to collections?
    + link to download all picklist options?

Not implemented!!!

+ Request
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 200 (application/json)

        {
            "links": {
                "termsets": "https://tenant.acrolinx.cloud/api/v1/terminology/views?useForChecking=match(true)"
            }
        }

## View resource [/api/v1/terminology/views/{id}]

asdfsdf

## Get views [GET /api/v1/terminology/views{?useForChecking,sort,p,limit}]

Returns a list of stored views, visible to the authenticated client.

+ Parameters
    + useForChecking: `match(true)` (enum[string], optional)
        Filters views by their "useForChecking" attribute.

        See XXX for a general description on how filtering works in Acrolinx REST-APIs.
        + Members
            + `match(true)`
            + `match(false)`
    + sort: `displayName` (enum[string], optional)
        Specifies the order in which the views appear in the result.

        See XXX for a general description on how sorting works in Acrolinx REST-APIs.
        + Members
            + `displayName`
    + p: `1` (number, optional) - Result page if a limit is given. Starts with 1.
    + limit: `10` (number, optional) - Maximum number of results per page.

+ Request
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 200 (application/json)

        {
            "view": [
                {
                    "id": "850ec0e3-9dd2-48f0-bb9c-8ade80316584",
                    "displayName": "Marketing",
                    "useForChecking": true,
                    "query": "[some query params]",
                    "links": {
                        "terms/en": "https://tenant.acrolinx.cloud/api/v1/terminology/terms?[some query params]&language=checkedAs(en)",
                        "terms/de": "https://tenant.acrolinx.cloud/api/v1/terminology/terms?[some query params]&language=checkedAs(de)",
                        "terms/zh": "https://tenant.acrolinx.cloud/api/v1/terminology/terms?[some query params]&language=checkedAs(zh)"
                    }
                }, {
                    "id": "850ec0e3-9dd2-48f0-bb9c-8ade80316585",
                    "displayName": "Documentation",
                    "useForChecking": true,
                    "query": "[other query params]",
                    "links": {
                        "terms/en": "https://tenant.acrolinx.cloud/api/v1/terminology/terms?[other query params]&language=checkedAs(en)",
                        "terms/de": "https://tenant.acrolinx.cloud/api/v1/terminology/terms?[other query params]&language=checkedAs(de)",
                        "terms/zh": "https://tenant.acrolinx.cloud/api/v1/terminology/terms?[other query params]&language=checkedAs(zh)"
                    }
                }
            ],
            "meta": {
            }
        }

## Get view [GET /api/v1/terminology/views/{uuid}]

Returns a stored view, visible to the authenticated client.

TODO:
+ More errors

+ Parameters
    + uuid: `850ec0e3-9dd2-48f0-bb9c-8ade80316584` (string, required) - id of the returned view

+ Request
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 200 (application/json)
    + Attributes
        + view (View)

+ Response 404

## Create view [POST /api/v1/terminology/views]

Creates a new view. Note that the id send with the request is ignored and a new one is generated.

TODO:
+ More errors

+ Attributes
    + view (View)

+ Request (application/json)
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 201 (application/json)
    + Headers

            Location: https://tenant.acrolinx.cloud/api/v1/terminology/views/{uuid}

    + Attributes
        + view (View)

## Update view [PUT /api/v1/terminology/views/{uuid}]

Updates a view.

TODO:
+ More errors

+ Attributes
    + view (View)

+ Parameters
    + uuid: `850ec0e3-9dd2-48f0-bb9c-8ade80316584` (string, required) - id of the returned view

+ Request (application/json)
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 200 (application/json)
    + Attributes
        + view (View)

+ Response 400 (application/json)
    + Attributes
        + error (ErrorResponse)

+ Response 404

## Delete view [DELETE /api/v1/terminology/views/{uuid}]

Deletes a view.

TODO:
+ More errors (authorization)

+ Parameters
    + uuid: `850ec0e3-9dd2-48f0-bb9c-8ade80316584` (string, required) - id of the returned view

+ Request
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 204
+ Response 404

## Terms resource [/api/v1/terminology/terms/{uuid}{?name,language,status,p,limit}]

### Get terms [GET]
Returns a list of stored terms.

+ Parameters
    + name: `match(true)` (enum[string], optional)
        Filters terms by their surface.

        See XXX for a general description on how filtering works in Acrolinx REST-APIs.
        + Members
            + `match(true)`
            + `match(false)`
    + language: `match([language-id])` (string, optional)
        Filters terms by their language.

        See XXX for a general description on how filtering works in Acrolinx REST-APIs.
    + status: `match([status-id])` (string, optional)
        Filters terms by their status.

        See XXX for a general description on how filtering works in Acrolinx REST-APIs.
    + p: `1` (number, optional) - Result page if a limit is given. Starts with 1.
    + limit: `10` (number, optional) - Maximum number of results per page.

+ Request
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 200 (application/json)
    + Attributes
        + term (array[Term])
        + meta (PaginationMetadata)

### Get a term [GET]

Returns a single term.

TODO:
+ More errors (authorization)

+ Parameters
    + uuid: `850ec0e3-9dd2-48f0-bb9c-8ade80316584` (string, required) - id of the requested term

+ Request
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 200 (application/json)
    + Attributes
        + term (Term)

+ Response 404

### Create a term [POST]

Creates a new term.

TODO:
+ More errors (authorization, validation)

+ Attributes
    + term (Term)

+ Request (application/json)
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 201 (application/json)
    + Headers

            Location: https://tenant.acrolinx.cloud/api/v1/terminology/terms/{uuid}

### Update a term [PUT]

Updates a term.

TODO:
+ More errors (authorization, validation)

+ Parameters
    + uuid: `850ec0e3-9dd2-48f0-bb9c-8ade80316584` (string, required) - id of the updated term

+ Attributes
    + term (Term)

+ Request (application/json)
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 200 (application/json)
    + Attributes
        + term (Term)

+ Response 404

### Delete a term [DELETE]

Deletes a term.

TODO:
+ More errors (authorization)

+ Parameters
    + uuid: `850ec0e3-9dd2-48f0-bb9c-8ade80316584` (string, required) - id of the deleted term

+ Request
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 204
+ Response 404

## Languages resource [/api/v1/terminology/languages/{uuid}]


## Get languages [GET]
Returns a list of all defined languages.

+ Request
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 200 (application/json)
    + Attributes
        + language (array[Language])
        + meta (PaginationMetadata)

# Get a language [GET]

Returns a single language.

TODO:
+ More errors (authorization)

+ Request
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Parameters
    + uuid: `850ec0e3-9dd2-48f0-bb9c-8ade80316584` (string, required) - id of the requested language

+ Response 200 (application/json)
    + Attributes
        + language (Language)

+ Response 404

# Create a language [POST]

Creates a new language.

TODO:
+ More errors (authorization, validation)

+ Attributes
    + language (Language)

+ Request (application/json)
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 201 (application/json)
    + Headers

            Location: https://tenant.acrolinx.cloud/api/v1/terminology/languages/{uuid}

# Update a language [PUT]

Updates a language.

TODO:
+ More errors (authorization, validation)

+ Parameters
    + uuid: `850ec0e3-9dd2-48f0-bb9c-8ade80316584` (string, required) - id of the updated language

+ Attributes
    + language (Language)

+ Request (application/json)
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 200 (application/json)
    + Attributes
        + language (Language)

+ Response 404

# Not implemented [DELETE]

Deletes a language.

TODO:
+ More errors (authorization)

+ Parameters
    + uuid: `850ec0e3-9dd2-48f0-bb9c-8ade80316584` (string, required) - id of the deleted language

+ Request
    + Header

            Auth-Token: 123579080a8d1fee12490a90dc3

+ Response 204
+ Response 404

# Group Other methods in existing API - TODO

Checking API:
* Contribute as Term (may be moved to Terminology API)

Core Service:
* get broadcast messages - integrate into "index" call?
* is user self reg enabled - integrate into "index" call?
* create user - not needed right now? should be part of User API

Findability:
* get/update target keywords - may link to existing methods?
* get keyword info - maybe link to existing method for now?

ExtraInfo API:
* get extra info tab infos - maybe link to existing methods in "index" call for now?

Checking Profiles:
* get and update user settings? get and update profile user settings? what is this?

Feedback API
* submit flag feedback - will be reimplemented anyway

Reuse API
* deprecated anyway

Debug API
* not needed for now - special use case

Monitoring API
* not needed for now - special use case
